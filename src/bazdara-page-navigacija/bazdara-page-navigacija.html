<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/paper-toast/paper-toast.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../font-import/font-import.html">
<link rel="import" href="../leaflet-import/leaflet-import.html">

<dom-module id="bazdara-page-navigacija">
  <template>
    <style>
      :host {
        display: block;
      }

      :host #map {
        height: calc(100vh - 130px);
        width: 100%;
        border: none;
      }

      :host .leaflet-left {
        z-index: 0 !important;
      }

      :host .download-button {
        margin-top: -65px;
        position: absolute;
        background: #fff;
        right: 5px;
      }

      @media (max-width: 600px) {
        :host #map {
          height: calc(100vh - 130px)
        }
      }
    </style>
    <div id="map"></div>
    <paper-toast id="toast0" text=""></paper-toast>
    <!-- <paper-button disabled class="download-button" raised on-click="downloadTiles"> <iron-icon icon="icons:cloud-download"></iron-icon></paper-button> -->
  </template>

  <script>
      Polymer({
        is: 'bazdara-page-navigacija',
        properties: {

        },

        /**
         * reference to the leaflet map
         *
         * @property map
         * @type L.map
         */
        _map: undefined,

        _baseLayer: undefined,
        _arso: undefined,

        ready: function() {
          // TODO09: Workaround for removed domReady event
          var me = this;
          setTimeout(function() {
            me.domReady();
          }, 1);
          setInterval(function() {
            document.querySelector('bazdara-page-navigacija').redrawMap()
          }, 100);
        },
        domReady: function() {

          var southWest = L.latLng(73.4483, -27.4813),
            northEast = L.latLng(27.6393, 39.3650),
            mybounds = L.latLngBounds(southWest, northEast);

          var map = L.map(this.$.map, {
            maxBounds: mybounds,
            zoom: 15,
            minZoom: 5,
            maxZoom: 18
          });

          this._map = map;
          map.setView([45.5282, 13.5681], 15);
          var baseLayer = L.tileLayer('https://tile.bazdara.com/{z}/{x}/{y}.png', {
            attribution: '<a href="https://www.bazdara.com">Bazdara</a> | <a href="http://osm.org/copyright" target="_blank">OpenStreetMap</a>'
          });
          this._baseLayer = baseLayer;
          this._baseLayer.addTo(map);

           var arso = L.tileLayer('https://x.bazdara.com/navigacija.php?z={z}&x={x}&y={y}&r=mapnik', {
             attribution: '| Arso',
             tms: true,
             minZoom: 14,
             maxNativeZoom: 16,
             transparent: true,
             opacity: 0.75
           });
           this._arso = arso;
           this._arso.addTo(map);

           L.Icon.Default.imagePath = '/images/map';

           var track = new L.KML("/data/data.xml", {async: true});
           this._map.addLayer(track);

           //var izobate = new L.KML("/data/izobate.kml", {async: true});
           //this._map.addLayer(izobate);
           //this._map.addControl(new L.Control.Layers({}, {'Izobate':izobate}));

          var geometWind = L.tileLayer.wms("https://x.bazdara.com/geomet/", {
            layers: 'GDPS.ETA_UU',
            format: 'image/png',
            transparent: true,
            attribution: "Environment Canada",
            opacity: 0.40
          });

          var geometRain = L.tileLayer.wms("https://x.bazdara.com/geomet/", {
            layers: 'GDPS.ETA_RT',
            format: 'image/png',
            transparent: true,
            attribution: "Environment Canada",
            opacity: 0.40
          });

          this._map.addControl(new L.Control.Layers({}, {'Boje in svetilniki':track, 'Veter':geometWind, 'Padavine':geometRain}));

          var lc = L.control.locate({
            position: 'topleft', // set the location of the control
            layer: undefined, // use your own layer for the location marker, creates a new layer by default
            drawCircle: true, // controls whether a circle is drawn that shows the uncertainty about the location
            setView: 'untilPan', // automatically sets the map view to the user's location, enabled if `follow` is true
            keepCurrentZoomLevel: false, // keep the current map zoom level when displaying the user's location. (if `false`, use maxZoom)
            stopFollowingOnDrag: false, // stop following when the map is dragged if `follow` is true (deprecated, see below)
            remainActive: false, // if true locate control remains active on click even if the user's location is in view.
            markerClass: L.circleMarker, // L.circleMarker or L.marker
            circleStyle: {}, // change the style of the circle around the user's location
            markerStyle: {},
            followCircleStyle: {}, // set difference for the style of the circle around the user's location while following
            followMarkerStyle: {},
            icon: 'fa fa-map-marker', // class for icon, fa-location-arrow or fa-map-marker
            iconLoading: 'fa fa-spinner fa-spin', // class for loading icon
            iconElementTag: 'span', // tag for the icon element, span or i
            circlePadding: [0, 0], // padding around accuracy circle, value is passed to setBounds
            metric: true, // use metric or imperial units
            onLocationError: function(err) {
              alert(err.message)
              toast0.text = 'Can\'t find your location.';
              toast0.open();
            }, // define an error callback function
            onLocationOutsideMapBounds: function(context) { // called when outside map boundaries
              alert(context.options.strings.outsideMapBoundsMsg);
            },
            showPopup: true, // display a popup when the user click on the inner marker
            strings: {
              title: "Show me where I am", // title of the locate control
              metersUnit: "meters", // string for metric units
              feetUnit: "feet", // string for imperial units
              popup: "You are within {distance} {unit} from this point", // text to appear if user clicks on circle
              outsideMapBoundsMsg: "You seem located outside the boundaries of the map" // default message for onLocationOutsideMapBounds
            },
            locateOptions: {
              enableHighAccuracy: true,
              maxZoom: 16,
              minZoom: 14,
            } // define location options e.g enableHighAccuracy: true or maxZoom: 10
          }).addTo(map);

          var windButton = L.easyButton({
            states: [{
              stateName: 'windOn', // name the state
              icon: '<i class="fa fa-long-arrow-down"></i>', // and define its properties
              title: 'Add Wind Layer', // like its title
              onClick: function(btn, map) { // and its callback
                geometWind.addTo(map);
                btn.state('windOff'); // change state on click!
              }
            }, {
              stateName: 'windOff',
              icon: '<i class="fa fa-long-arrow-down" style="color:#FC8428"></i>',
              title: 'Remove Wind Layer',
              onClick: function(btn, map) {
                map.removeLayer(geometWind)
                btn.state('windOn');
              }
            }]
          });
          windButton.addTo(map);

          var rainButton = L.easyButton({
            states: [{
              stateName: 'rainOn', // name the state
              icon: '<i class="fa fa-cloud"></i>', // and define its properties
              title: 'Add rain Layer', // like its title
              onClick: function(btn, map) { // and its callback
                geometRain.addTo(map);
                btn.state('rainOff'); // change state on click!
              }
            }, {
              stateName: 'rainOff',
              icon: '<i class="fa fa-cloud" style="color:#FC8428"></i>',
              title: 'Remove rain Layer',
              onClick: function(btn, map) {
                map.removeLayer(geometRain)
                btn.state('rainOn');
              }
            }]
          });
          rainButton.addTo(map);

          var cacheButton = L.easyButton({
            states: [{
              stateName: 'cacheOn', // name the state
              icon: 'fa-download', // and define its properties
              title: 'Cache visible map', // like its title
              onClick: function(btn, map) { // and its callback
                if (map.getZoom() > 10) {
                  document.querySelector('bazdara-page-navigacija').downloadTiles();
                  this.disable();
                  btn.state('cacheOff'); // change state on click!
                } else {
                  toast0.text = 'Map size is too big. Try a bigger zoom.';
                  toast0.open();
                }
              }
            }, {
              stateName: 'cacheOff',
              icon: 'fa-download',
              title: 'Remove cache Layer',
              onClick: function(btn, map) {
                this.disable();
                //                btn.state('cacheOn');
              }
            }]
          });
          cacheButton.addTo(map);

        },

        redrawMap: function() {
          this._map.invalidateSize(true);
        },

        downloadTiles: function() {
          console.log('downloadTiles called');
          map = this._map;
          var numberOfTiles = this.calculateNbTiles(16);
          toast0.close();
          toast0.text = 'number of tiles to download: ' + numberOfTiles;
          toast0.open();
          this.prefetchTiles(16);
        },

        /**
         * Functions below from https://github.com/mWater/offline-leaflet-map
         */
        calculateNbTiles: function(zoomLevelLimit) {
          var count, key, tileImagesToQuery;
          count = 0;
          tileImagesToQuery = this._getTileImages(zoomLevelLimit);
          for (key in tileImagesToQuery) {
            count++;
          }
          return count;
        },
        prefetchTiles: function(zoomLevelLimit) {
          var key, tileImagesToQuery;
          tileImagesToQuery = this._getTileImages(zoomLevelLimit);
          for (key in tileImagesToQuery) {
            var t = tileImagesToQuery[key];
            var url = this._createURL(t.x, t.y, t.z);
            /* @TODO: this needs to be done one at a time with progress indicator
             * otherwise there will be memory troubles
             * check if: https://github.com/mWater/offline-leaflet-map/blob/master/dist/offlinemap.js
             * has a good solution
             */
            fetch(url).then(function(response) {
              console.log('fetched ' + response.url);
              toast0.text = 'fetched ' + response.url;
              toast0.open();
            });
          }
        },
        _getTileImages: function(zoomLevelLimit) {
          var arrayLength, bounds, i, j, map, maxX, maxY, minX, minY, point, roundedTileBounds, startingZoom, tileBounds, tileImagesToQuery, tileSize, tilesInScreen, x, y, _i, _j, _k, _ref, _ref1, _ref2, _ref3;
          zoomLevelLimit = zoomLevelLimit || this._map.getMaxZoom();
          tileImagesToQuery = {};
          map = this._map;
          startingZoom = map.getZoom();
          bounds = map.getPixelBounds();
          tileSize = '256';
          roundedTileBounds = L.bounds(bounds.min.divideBy(tileSize)._floor(), bounds.max.divideBy(tileSize)._floor());
          tilesInScreen = [];
          for (j = _i = _ref = roundedTileBounds.min.y, _ref1 = roundedTileBounds.max.y; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; j = _ref <= _ref1 ? ++_i : --_i) {
            for (i = _j = _ref2 = roundedTileBounds.min.x, _ref3 = roundedTileBounds.max.x; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = _ref2 <= _ref3 ? ++_j : --_j) {
              tilesInScreen.push(new L.Point(i, j));
            }
          }
          tileBounds = L.bounds(bounds.min.divideBy(tileSize), bounds.max.divideBy(tileSize));
          minY = tileBounds.min.y;
          maxY = tileBounds.max.y;
          minX = tileBounds.min.x;
          maxX = tileBounds.max.x;
          arrayLength = tilesInScreen.length;
          for (i = _k = 0; 0 <= arrayLength ? _k < arrayLength : _k > arrayLength; i = 0 <= arrayLength ? ++_k : --_k) {
            point = tilesInScreen[i];
            x = point.x;
            y = point.y;
            this._getZoomedInTiles(x, y, startingZoom, zoomLevelLimit, tileImagesToQuery, minY, maxY, minX, maxX);
            this._getZoomedOutTiles(x, y, startingZoom, 0, tileImagesToQuery, minY, maxY, minX, maxX);
          }
          return tileImagesToQuery;
        },
        _getZoomedInTiles: function(x, y, currentZ, maxZ, tileImagesToQuery, minY, maxY, minX, maxX) {
          this._getTileImage(x, y, currentZ, tileImagesToQuery, minY, maxY, minX, maxX, true);
          if (currentZ < maxZ) {
            minY *= 2;
            maxY *= 2;
            minX *= 2;
            maxX *= 2;
            this._getZoomedInTiles(x * 2, y * 2, currentZ + 1, maxZ, tileImagesToQuery, minY, maxY, minX, maxX);
            this._getZoomedInTiles(x * 2 + 1, y * 2, currentZ + 1, maxZ, tileImagesToQuery, minY, maxY, minX, maxX);
            this._getZoomedInTiles(x * 2, y * 2 + 1, currentZ + 1, maxZ, tileImagesToQuery, minY, maxY, minX, maxX);
            return this._getZoomedInTiles(x * 2 + 1, y * 2 + 1, currentZ + 1, maxZ, tileImagesToQuery, minY, maxY, minX, maxX);
          }
        },
        _getZoomedOutTiles: function(x, y, currentZ, finalZ, tileImagesToQuery, minY, maxY, minX, maxX) {
          this._getTileImage(x, y, currentZ, tileImagesToQuery, minY, maxY, minX, maxX, false);
          if (currentZ > finalZ) {
            minY /= 2;
            maxY /= 2;
            minX /= 2;
            maxX /= 2;
            return this._getZoomedOutTiles(Math.floor(x / 2), Math.floor(y / 2), currentZ - 1, finalZ, tileImagesToQuery, minY, maxY, minX, maxX);
          }
        },
        _getTileImage: function(x, y, z, tileImagesToQuery, minY, maxY, minX, maxX) {
          var key;
          if (x < Math.floor(minX) || x > Math.floor(maxX) || y < Math.floor(minY) || y > Math.floor(maxY)) {
            return;
          }
          key = this._createTileKey(x, y, z);
          if (!tileImagesToQuery[key]) {
            return tileImagesToQuery[key] = {
              key: key,
              x: x,
              y: y,
              z: z
            };
          }
        },
        _createNormalizedTilePoint: function(x, y, z) {
          var nbTilesAtZoomLevel;
          nbTilesAtZoomLevel = Math.pow(2, z);
          while (x > nbTilesAtZoomLevel) {
            x -= nbTilesAtZoomLevel;
          }
          while (x < 0) {
            x += nbTilesAtZoomLevel;
          }
          while (y > nbTilesAtZoomLevel) {
            y -= nbTilesAtZoomLevel;
          }
          while (y < 0) {
            y += nbTilesAtZoomLevel;
          }
          return {
            x: x,
            y: y,
            z: z
          };
        },
        _createURL: function(x, y, z) {
          var tilePoint;
          tilePoint = this._createNormalizedTilePoint(x, y, z);
          return this._baseLayer.getTileUrl(tilePoint);
        },
        _createTileKey: function(x, y, z) {
          var tilePoint;
          tilePoint = this._createNormalizedTilePoint(x, y, z);
          return tilePoint.x + ", " + tilePoint.y + ", " + tilePoint.z;
        }


      });
  </script>
</dom-module>
